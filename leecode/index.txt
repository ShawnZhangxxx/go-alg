
10:正则表达式,动态规划 --未做



排序算法
    时间复杂度nlogn     空间复杂度      稳定性
    快排                              不具备稳定性,partion过程中相同的数
    堆排                n             不稳定,再形成大根堆过程中就破坏了顺序
    归并                              稳定

    时间复杂度n²
    选择
    冒泡
    插入


堆排序:
    topK 问题,


链表
判断是否是回文链表   : 1.用栈把链表都写入栈里 2.双指针,第二个指针每次走两步,找到中点,右边部分反转链表,两头往里比较,最后再恢复右边反转的链表
按照某个节点partition : 用三个链表 6个变量 大于的 小于的 等于的 之后再串起来,注意空链表
链表带随机指针的拷贝 :部分个节点是随机指向,无环: 把每个节点拷贝一份放到原始节点后面,再搞随机指针
判断有环链表: 有环链表有环必然环是死的不可能再出来,1.用hashset存 2.不用额外空间,用快慢指针,2倍指针一定会和慢指针相交,然后慢指针回到开头,在原点的指针一起动必然在环出相交,原理比较麻烦.
找两个链表的交点: 如果是有环链表分三种情况:一种是没交点 2.有,尾部重合 和有环链表一样快慢指针

递归:先写一个最基础的,然后把递归逻辑加进去
数遍历: 打印左边:打印中间:打印右边;   打印左边:递归调用 中间:打印 右边:递归调用  边界递归会回弹回去

树:
中序遍历:node.leftNode.middleSort() ; fmt.println(node.data) ; node.rightNode.middleSort()
非递归先序遍历: 每次 栈中弹出一个节点;打印;压入右节点;压入左节点;  循环
非递归后序遍历: 两个栈,一个存数据栈, 每次栈弹出一个节点,放入备用栈; 压入左节点,压入右节点放到栈1;    栈1弹出,放入备用循环; 最后弹出备用栈
非递归中序遍历: 左边界进栈,依次弹出打印, 每次弹出右边界亦是如此->左边界全部压栈


宽度遍历用队列: 头结点放到队列;弹出就打印;先放左再放右到队列; 重复
求树最大宽度: 宽度优先遍历,用俩个队列统计两层 ;或者用一个map,记每个节点所在层数

搜索二叉树:左树比节点小,右树比他大; 中序遍历一定是升序的